# AISocietyIndividualProject
The individual project for my minor AI in Society and semester 7 of my education at FHICT. For a small overview of the project visit:
https://www.survAIvor.nl


This Repository includes the Survival AI project, as well as the 
Jupyter notebook and Proof of concepts I made during the semester.

Projects: 
    - Run the main file for the following projects from ./simulation

- Surival Environment -> main.py
- Surival Environment map creator -> /map_creator/map_creator_main.py
- Genetic Algorithm pathfinding -> /ga_example/ga_main.py
- Snake AI -> /snake_ai/main.py
- Cartpole balancing -> /gym/gym_main.py
<br/><br/>
> Note that the Snake AI can use either Neat or my feed forward neural network, since it is using a strategy pattern. And that both the survival simulation and snake can train and save their results without having to run Pygame to speed up the process.

# Install packages

## pip
    pip install -r ./simulation/requirements.txt

If necessary grab the latest requirements file from the artifacts generated by Github actions, that can be found [HERE](https://github.com/MatthijsFontys/AISocietyIndividualProject/actions)
<br/>
## 1.
![Updating requirement file step 1](https://i.imgur.com/2EKBwtr.png)
## 2.
![Updating requirement file step 2](https://i.imgur.com/XcY8zfr.png)

## poetry
    cd simulation
    poetry install



# Optimizations
This optimization part is included, because it is not closely related to AI and did not want to include it in my JupyterNotebook.

I took some optimization precautions to keep the simulation running smoothly and to improve the rate at which the AI can train.
These are the precautions I took:
- Occlusion culling. This means hiding the objects that can not be seen by the camera, they still live in the world and move around, they are just not rendered to the canvas.
- Removing square root calculations. Calculating the distance between vectors requires a relatively slow square root calculation, which can be ommited by checking against the distance squared.
- Caching variables that otherwise would have to be calculated multiple times per frame.
- Object pooling for vectors. This means that the program makes a lot of vectors during the first frame, but then re-uses these vectors. This speeds up the program, because the program creates a lot of vector objects for calculating positions and collisions. If it didn't re-use its vectors the computer would need to re-allocate memory for each Vector that is created or cleaned up by the garbage collector.
- Checking collisions. Because I only want to use PyGame for drawing and don't want to use it for calculating movement I had to write my own collions. But this would require to check every objects against every object, which would be quite slow. O(nÂ²). To speed this up I store every object in the world in a 2d array that represents world location. This essentially is a lookup table for nearby objects. This way an object can ask the lookup table for all nearby objects and check collisions that way.

<br/>
<img src="https://i.imgur.com/5uU563y.png" width="100%" height="auto">